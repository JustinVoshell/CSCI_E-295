/* scannerCLI.c
   Justin Voshell - justin.voshell@me.com
   CSCI E-295 Spring 2012

   Provides a command line interface to the flex-generated scanner.

   See documentation of main() for more info.
*/

#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#include "scanner.h"
#include "scanner_codes.h"

/*
  Strings longer than MAX_INLINE_STRLEN are output on their own line
*/         
#define MAX_INLINE_STRLEN 30

/*
  Main function returns EXIT_OK unless we encounter an out-of-memory error, 
  in which case it returns EXIT_OUT_OF_MEMORY
*/
#define EXIT_OK 0
#define EXIT_OUT_OF_MEMORY 1

/* 
   Interface to scanner generated by flex from scanner.lex.  Each call to 
   yylex() updates yytext, yyleng, yylval, and possibly yylineno
*/

extern FILE* yyin;                      /* Input file for scanner             */
int yylex();                            /* Returns next token from scanner    */
extern char* yytext;                    /* Points to most recent lexeme.      */
extern int yyleng;                      /* Length of string stored at yytext  */
extern int yylineno;                    /* Line number of most recent lexeme  */
void* yylval;                           /* Points to attribute for token      */

/*
  Subroutines called from main().  
  Each is documented in its implementation after main().
*/

const char* open_io(FILE** inputStream, const char* inputName, FILE** outputStream, const char* outputName);
void close_io(FILE* inputStream, FILE* outputStream);
int handle_token(const int token, void* attribute, FILE* output);
void fprint_id(FILE* output, const char* id);
void fprint_integer_t(FILE* output, const integer_t* integer);
void fprint_string_t(FILE* output, const string_t* string);
void fprint_error(FILE* output, const int errorCode);
void fprint_lexeme(FILE* output, const char* inputName, const char* lexeme, const int lexemeLength, const int lineNumber);

/* main

   Entry point for scanner command line interface.  The approach taken here
   began as a copy of Willenson's scanner_main.c provided as an example in 
   section.

   I/O is established based on the command line arguments.  Then a scan loop is 
   run, calling yylex() to fetch tokens until there are no more (or until an out
   of memory error or an error that has resulted in scanning to EOF is detected)

   For each result returned from yylex(), we output a line indicating:
   - the input filename and line number
   - the input text read by yylex()
   - the token value returned or an error message
   - for tokens with an token attribute, a representation of the attribute
     value is also output

   Usage        : scannerCLI [input_file] [output_file]

                  - input_file is the name of a file to read tokens from.  
                    if input_file is not provided or is "-", stdin is used.

                  - output_file is the name of a file to write output to.
                    if output_file is not provied of is "-", stdout is used. 

   Returns      : EXIT_OUT_OF_MEMORY if out of memory,
                  EXIT_OK otherwise

   Side-effects : input_file is opened for reading for the duration of the
                  program.  output_file is opened for writing for the 
                  duration of the program.  Data is written to the
                  output_file.  Heap memory may be allocated and freed.
 */
int main(int argc, char** argv)
{
  /* Input source */
  FILE* input;

  /* Output target */
  FILE* output;
  
  /* Result of calling yylex() */
  int yylex_result;

  /* Opens input and output files (or assigns them to stdin and/or stdout).
     inputName is set to a string we can output to the user describing the 
     input source.  This will either be 'stdin' or the input filename.
  */
  const char* inputName = open_io(&input, argc < 2 ? NULL : argv[1], &output, argc < 3 ? NULL : argv[2]);

  /* Initialize code table defined in scanner_codes.h */
  init_code_table();

  /* Scan */
  yyin = input;
  for (yylex_result = yylex(); 0 != yylex_result; yylex_result = yylex())
  {  
    /* A zero result from yylex() means we've reached EOF */
    if (yylex_result !=0)
    {
      /* Print information about input text */
      fprint_lexeme(output, inputName, yytext, yyleng, yylineno);
    }
    else 
    {
      break;
    }

    /* Handle tokens */
    if (IS(TOKEN, yylex_result))
    {
      if (handle_token(yylex_result, yylval, output)) return EXIT_OUT_OF_MEMORY;
    }

    /* Handle errors */
    else if (IS(ERROR, yylex_result)) 
    {
      fprint_error(output, yylex_result);
      
      /* 
         If we've scanned to EOF and received an error, or if we're out of
         memory, we should terminate. 
      */
      if (IS(EOF_ERROR, yylex_result) || E_OUT_OF_MEMORY == yylex_result)
      {
        close_io(input, output);
        return EXIT_OK;
      }
    }

    /* If the scanner is returning something we don't understand, terminate.  */
    else 
    {
      fprintf(output, "ERROR: Unrecognized scanner code: %i\n", yylex_result);
      break;
    }
  }

  /* Scan complete */ 
  close_io(input, output);
  return EXIT_OK;
}

/* handle_token

   Takes a token value (and, optionally, a token attribute value), and writes
   a string serialization to output.

   Parameters   : token (const int)
                  - token value returned from yylex()

                  attribute (void*)
                  - token attribute value returned from yylex() in yylval.
                    if no attribute is provided, or none is requied for
                    the given token, NULL may be provided.  If an attribute
                    is expected and NULL is provided, an out of memory error
                    is assumed.

   Returns      : EXIT_OUT_OF_MEMORY if out of memory, 
                  0 otherwise
 
   Side-effects : Writes data to output.
                  If attribute is provided and is not NULL, it is freed.
*/
int handle_token(const int token, void* attribute, FILE* output)
{
  /* Decoded string name for token */
  const char* tokenName;

  if (!(tokenName = decode(token)))
  {
    fprintf(output, "ERROR: Unrecognized token: %i\n", token);
    return 0;
  }

  if (IS(WITH_ATTRIBUTE, token)) 
  {
    /* 
       If a token is supposed to have an attribute and doesn't, a malloc failed in 
       the scanner.
    */
    if (!attribute)
    {
      fprint_error(output, E_OUT_OF_MEMORY);
      return EXIT_OUT_OF_MEMORY;
    }

    /*
       Call the appropriate function to format and output the attribute value
    */
    if (IDENTIFIER == token)            fprint_id(output, (char*)attribute); 
    else if (LITERAL_INTEGER == token)  fprint_integer_t(output, (integer_t*)attribute);
    else if (LITERAL_STRING == token)   fprint_string_t(output, (string_t*)attribute);

    /*
       Attribute values are allocated in the scanner, so we free them now that we've 
       finished up with them.
    */
    free(attribute);
  }

  /* If there isn't an attribute, outputting the token value is easy */
  else if (IS(KEYWORD, token))          fprintf(output, "KEYWORD: %s\n", tokenName);
  else if (IS(OPERATOR, token))         fprintf(output, "OPERATOR: %s\n", tokenName);
  else if (IS(SEPARATOR, token))        fprintf(output, "SEPARATOR: %s\n", tokenName);

  return 0;
}

/* fprint_id

   Prints an identifier token's attribute value to output.

   Parameters   : output (FILE*)
                  - output file to write to

                  id (const char*)
                  - attribute value for IDENTIFIER token
 
   Returns      : void

   Side-effects : Writes data to output.
*/
void fprint_id(FILE* output, const char* id)
{
  fprintf(output, "IDENTIFIER: %s\n", id);
}

/* fprint_integer_t

   Serializes an integer_t structure to output.

   Parameters   : output (FILE*)
                  - output file to write to

                  integer (const integer_t*)
                  - attribute value for LITERAL_INTEGER token

   Returns      : void
   Side-effects : Writes data to output.
*/
void fprint_integer_t(FILE* output, const integer_t* integer)
{
  fprintf(output, "INTEGER: %-12lu\t", integer->value);
  fprintf(output, "TYPE: %-6s\t", decode(integer->type));
  fputs(0 == integer->overflow ? "NO OVERFLOW\n" : "OVERFLOW\n", output);
}

/* fprint_string_t

   Serializes a string_t structure to output.  Attempts to print the string
   value inline with the other output if it is less than MAX_INLINE_STRLEN in
   length. Longer strings are wrapped in STRING==> / <==STRING before being
   output.

   Parameters   : output (FILE*)
                  - output file to write to

                  string (string_t*)
                  - attribute value for LITERAL_STRING token

   Returns      : void
   Side-effects : Writes data to output.
*/
void fprint_string_t(FILE* output, const string_t* string) 
{
  /* Used as loop index */
  size_t idx;

  /* We copy the string attribute value character by character instead of 
     relying on standard C functions: they will stop at a NUL while we
     want to copy out the entire attribute value.

     We output the string inline if we can, otherwise we mark its beginning
     and end and then dump the whole string.
  */
  if (string->length <= MAX_INLINE_STRLEN)
  {
    fputs("STRING: ", output);
    for (idx = 0; idx < string->length; idx++)
    {
      fputc(string->buffer[idx], output);
    }
    fputs("\n", output);
  }
  else
  {
    fputs("\nSTRING==>", output);
    for (idx = 0; idx < string->length; idx++)
    {
      fputc(string->buffer[idx], output);
    }
    fputs("<==STRING\n", output);
  }
}

/* fprint_error

   Decodes an error code and writes the corresponding error message to output.
   If the error code cannot be decoded, "UNKNOWN ERROR" is written out.

   Parameters   : output (FILE*)
                  - output file to write to

                  errorCode (int)
                  - an integer value from the errors section of scanner_codes.h

   Returns      : void
   Side-effects : Writes data to output.
*/
void fprint_error(FILE* output, const int errorCode)
{
  /* Decoded error message */
  const char* errorMessage;

  if ((errorMessage = decode(errorCode)))
  {
    fprintf(output, "ERROR: %s\n", errorMessage);
  }
  else
  {
    fprintf(output, "UNKNOWN ERROR\n");
  }
}

/* fprint_lexeme

   Prints to output the character sequence that caused yylex() to return.  The 
   inputName and line number are also output.

   Example output:
   scannerTestData.txt:44: TEXT: const

   Parameters   : output (FILE*)
                  - output file to write to

                  inputName (const char*)
                  - name of input source.  A filename or 'stdin'.

                  lexeme (const char*)
                  - text returned from yylex() in yytext

                  lexemeLength (const int)
                  - length of lexeme (returned from yylex() in yyleng)

                  lineNo (const int)
                  - line number of input source lexeme was read from (yylineno)

   Returns      : void
   Side-effects : Writes data to output
*/
void fprint_lexeme(FILE* output, const char* inputName, const char* lexeme, const int lexemeLength, const int lineNo)
{
  fputs(inputName, output);
  fprintf(output, ":%i: ", lineNo);
  
  if (lexemeLength <= MAX_INLINE_STRLEN)
  {
    fprintf(output, "TEXT: %-30s\t", lexeme);
  }
  else
  {
    fprintf(output, "\nTEXT==>%s<==TEXT\n", lexeme);
  }
}

/* open_io

   Opens an input file for reading and an output file for writing.  

   Parameters   : inputStream (FILE**)
                  - A pointer to the input file is stored at *inputStream

                  inputName (const char *)
                  - If provided, the filename to open for reading.  If "-" or 
                    null, stdin is used.

                  outputStream (FILE**)
                  - A pointer to the output file is stored at *outputStream

                  outputName (const char*)
                  - If provided, the filename to open for writing.  If "-" or
                    null, stdout is used.

   Returns      : A string name for the input file.  Either the inputName (if it
                  represents a file name or "stdin".

   Side-effects : If inputName is a filename, that file is opened for reading.
                  If outputName is a filename, that file is opened for writing.
                  *inputStream is set to the location of the input FILE*
                  *outputStream is set to the location of the output FILE*
*/
const char* open_io(FILE** inputStream, const char* inputName, FILE** outputStream, const char* outputName)
{
  if (!inputName || !strcmp("-", inputName)) 
  {
    *inputStream = stdin;
  }
  else
  {
    *inputStream = fopen(inputName, "r");
  }

  if (!outputName || !strcmp("-", outputName))
  {
    *outputStream = stdout;
  }
  else
  {
    *outputStream = fopen(outputName, "w");
  }

  return (stdin == *inputStream) ? "stdin" : inputName;
}

/* close_io

   Closes the input and output files.

   Parameters   : input (FILE*)
                  - If input does not point to stdin, it is closed.

                  output (FILE*)
                  - If output does not point to stdout, it is closed.
 
   Returns      : void
 
   Side-effects : If input and/or output are not stdin/stdout, they are closed.
*/
void close_io(FILE* input, FILE* output)
{
  if (output != stdout)
  {
    fclose(output);
  }
  if (input != stdin)
  {
    fclose(input);
  }
}
